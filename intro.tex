\section{Introduction}
\label{sec:intro}

The online question and answering (Q\&A) forums, e.g., StackOverflow
(S/O) provide important resources for developers to learn how to use
software libraries and frameworks. While the code snippets in an S/O
answer are good starting points, they are often incomplete with
several missing details and contain ambiguous references, etc.  Zhang
{\em et al.}~\cite{zhang-icse19} have conducted a large-scale
empirical study on the nature and extent of manual adaptations of the
S/O code snippets by developers into their GitHub repositories.  They
reported that the adaptations between S/O code examples and their
GitHub counterpart projects are prevalent and non-trivial. The
qualitatively inspected all the adaptation cases and classified them
into 24 different adaptation types. They highlighted several
adaptation types including {\em type conversion}, {\em handling
  potential exceptions}, and {\em adding if
  checks}~\cite{zhang-icse19}. Among them, adding a \code{try-catch}
block to wrap the code snippet and enumerating all the handled
exceptions in the catch clause are frequently performed (132 cases out
of 629 S/O examples) yet not automated by existing code integration
techniques.

The adaptation process for exception handling is not trivial as Nguyen
{\em et al.}~\cite{xrank-fse20} have reported that it is challenging
for developers to learn and memorize what API method could cause
exceptions and what exceptions need to be handled. Kechagia {\em et
  al.}~\cite{kechagia-msr14} found that 19\% of the crashes in Android
applications could have been caused by insufficient documented
exceptions in Android APIs. Thus, it is desirable to have an automated
tool to recommend proper exception handling for such adaptation of
online code snippets.

There exist several approaches to automatically recommend proper
exception
handling~\cite{barbosa-bsse12,chanchal-scam14,barbosa-tse18,barbosa-tse16,xrank-fse20,throw-ase22}. They
can be classified into different categories. The first category of
approaches relies on a few {\em heuristics} on exception types, API
calls, and variable types to recommend exception handling
code~\cite{barbosa-bsse12}. These heuristic-based approaches do not
always work in all the cases. The second category of approaches
utilized {\em exception handling policies}, which are enforced in all
cases~\cite{barbosa-tse16,barbosa-saner18}. However, the policies need
to be pre-defined and encoded within the enforcing tools.  This is not
an ideal solution considering the fast evolution of software
libraries. To enable more flexibility than policy enforcement, the
third category leverages the {\em mining algorithms} that derives
similar exception handling for two similar code
fragments~\cite{chanchal-scam14}. While avoiding the hard-coding of
rules, these mining approaches suffer the issue of how much similar
for two fragments to be considered as having similar exception
handling. In fact, two API method calls in two different contexts
might require to handle the same exception. For example, two fragments
of code using JDK containing an opening of the files for different
purposes in two contexts might need to catch and handle the
\code{IOException} due to the call to
\code{java.io.nio.new\-Buffered\-Reader}.

To provide more flexibility in matching the code, the fourth category
follows the {\em information retrieval} (IR)
direction~\cite{xrank-fse20}. XRank~\cite{xrank-fse20} takes as input
a code fragment and recommends a ranked list of exceptions that need
to be handled in a \code{catch} clause. XHand~\cite{xrank-fse20}
recommends the exception handling code in a \code{catch} block for a
given code fragment. Both uses a fuzzy set technique to learn the
associations between the method calls (e.g.,
\code{new\-Buffered\-Reader}) and the exceptions (e.g.,
\code{IOException}). While the IR-based approach achieves higher
accuracy than others~\cite{xrank-fse20}, it has key limitations
that reduce its effectiveness. First, it is not straightforward to {\bf
  pre-define a threshold} for feature matching for a retrieval of an
element (e.g., an exception or API method). The effectiveness of those
IR techniques depends much on the correct value of such pre-defined
threshold. Second, the IR-based techniques rely on the {\bf lexical
  values} of the code tokens and API elements, which can be {\em
  ambiguous in an incomplete code snippet}. For example, the
\code{Document} class in \code{org.\-w3c.\-dom} of the W3C library has
the same simple name as the \code{Document} class in
\code{com.\-google.\-gwt.\-dom.\-client.\-Document} of the Google Web
Toolkit (GWT) library. An API method to open/write/read a
\code{Document} in the W3C library might need to catch a different set
of exceptions than the one in the GWT library. Those IR-based
techniques are not sufficiently flexible to handle such ambiguous
names. Third, the IR techniques {\em do not consider the {\bf context} of
  surrounding code}, thus, further suffering the ambiguity of
API methods and exceptions.
