\section{Motivation}
\label{motiv:sec}

\subsection{Motivating Examples}
\label{examples:sec}

\input{example1.tex}

Let us use a few real-world examples to explain the problem and
motivate our approach. Figure~\ref{fig:example1} displays a code
snippet in an answer to the StackOverflow (SO) question 15409223 on
how to ``add new paths for native libraries at runtime in Java''.  The
code snippet serves the illustrating purpose, thus, does not contain
all the details regarding what exceptions that need to be handled. It
just contains a throw of a generic \code{Exception} in the method
header (\code{addLibraryPath}). From the empirical study from Zhang
{\em et al.}~\cite{zhang-icse19}, this code snippet was adopted by the
developers into their Github project named \code{armint} as seen in
Figure~\ref{fig:example2}. In \code{armint} code, the developers
handle in a \code{try-catch} block the all possible exceptions caused
by \code{java\-.lang\-.Class\-.get\-Declared\-Field(...)} (line 7)
according to JDK's documentation including
\code{No\-Such\-Field\-Exception}, \code{Security\-Exception},
\code{Illegal\-Argument\-Exception}, and
\code{Illegal\-Access\-Exception} (line 24 of
Figure~\ref{fig:example2}).

In their study, Zhang {\em et al.}~\cite{zhang-icse19} have reported
that such adaptation is still largely manual due to the lack of
documentation for exception handling. Kechagia {\em et
  al.}~\cite{kechagia-msr14} found that 69\% of the methods from
Android packages in their stack traces had undocumented exceptions in
the Android API. The manual adaptation on exception handling by
inserting a \code{try-catch} block is quite popular (in 31 out 629
cases). Such manual adaptation could lead to exception-related bugs,
which could cause serious issues including crashes or unstable
states~\cite{xrank-fse20}. Thus, it is desirable to have an automated
tool to recommend proper exception handling in order to adapt the
incomplete code snippets. For example, what lines need to be included
in a \code{try-catch} block, and what exceptions need to be handled.

%spec, heuristic, mining, IR

To address the issue, several automated approaches have been proposed
to recommend proper exception
handling~\cite{xrank-fse20,barbosa-bsse12,chanchal-scam14,barbosa-tse18,barbosa-tse16}. Earlier
approaches utilized {\em heuristic strategies} on exception types,
method calls, and variables' types to recommend exception handling
code~\cite{barbosa-bsse12}. While the heuristics might not work in all
cases, {\em exception handling policies} could be
enforced~\cite{barbosa-tse16,barbosa-saner18}. However, the policies
must be pre-defined and encoded in the tool. To overcome that, the
{\em mining approaches} are based on the idea that similar code
requires similar exception handling~\cite{chanchal-scam14}. Some
approaches also leverage mined patterns to repair exception-handling
bugs~\cite{zhong-jss18}. A key issue with the mining approaches is
that the two code fragments might not be exactly matched, but they
share a few key elements that require the same exception handling.
Thus, Nguyen {\em et al.}~\cite{xrank-fse20} propose a {\em
  information retrieval} (IR) approach using a fuzzy set technique to
learn the associations between the method calls (e.g.,
\code{get\-Declared\-Field}) and the exceptions (e.g.,
\code{No\-Such\-Field\-Exception}, \code{Security\-Exception}, etc.)
that need to be handled. A key drawback of the IR approach is that it
relies on the threshold for a match in an retrieval, which might often
not be easily pre-defined.



\input{example2.tex}



\subsection{Observations}
\label{sec:obs}

To facilitate the reuse of code snippets in a forum, an automated tool
is needed to derive the fully-qualified names of the API elements in
the snippets so that the proper import statements are added in the
code. To build such a tool, we draw the motivation from the following
observations.

\vspace{2pt}
\noindent {\bf Observation 1} [{\em Regularity of API Usages}]. The
designers of software libraries have the intents for developers to use
certain API elements together (including API classes, method calls,
field accesses) in certain combinations and orders to achieve a
programming task. Those API elements do not occur randomly. For
example, in Figure~\ref{fig:example2} at line 2, in GWT, a variable of
the type \code{Button} (FQN:
\code{com.google.gwt.user.client.ui.Button}) is instantiated. Then, at
line 3, to set the handler of that GWT button, one needs to have a
method call to \code{addClickHandler} (FQN:
\code{com.google.gwt.user.client.ui.Button.add\-Click\-Handler}) on
the \code{Button} object with an argument of the type
\code{ClickHandler} (FQN:
\code{com\-.google\-.gwt\-.event\-.dom\-.client\-.ClickHandler}).  The
API elements are provided and intented to be used in such a code,
called {\em an API usage}. Thus, those API elements of API usages
frequently appear together in the client code using the
library. Figure~\ref{fig:example3} shows a complete example published
in the GWT tutorial website \code{gwtproject.org}. Providing all the
proper \code{import} statements, the author shows how to use the GUI
elements in GWT including \code{Button}. Specifically, at line 23,
despite using a different variable name \code{addStockButton}, the
method \code{addClickHandler} is called on a Button object (declared
at line 12) with the argument of the same type \code{ClickHandler}. In
brief, the source code in the public repositories could be a good
source for a model to implicitly learn the API usages to derive the
FQNs of the API elements in an incomplete snippet.

\input{example3.tex}

\vspace{2pt}
\noindent {\bf Observation 2} [{\em Dependencies/Relations among API
    Elements in a Usage}]. The dependencies/relations among the API
elements in a API usage can help a model better identify the FQNs of
the elements.  In Figure~\ref{fig:example3}, the API elements
\code{Button}, \code{addClickHandler}, and \code{ClickHandler} in GWT
have the program dependencies/relations among them. For example, in
GWT, to set a handler for a button, the object of the type
\code{Button} needs to be the {\em receiving object of the method
  call} to \code{addClickHandler}, which in turn needs to accept an
object of the type \code{ClickHandler} as an argument. These relations
exhibit in the client code using the GWT library, and are useful in
deciding the FQNs of its API elements. For example, in
Figure~\ref{fig:example2},~at line 3, if \code{addClickHandler} is
determined to be the API element
\code{com.\-google.\-gwt.\-user.\-client.\-ui.\-Button.\-add\-Click\-Handler}, the
FQN of the element at line 4 must be
\code{com\-.google\-.gwt\-.event\-.dom\-.client\-.ClickHandler}.  The
other direction of reasoning is applicable as well. In general, if a
model can learn the dependencies/relations among API elements, it
could leverage such knowledge to decide the FQNs of all those APIs at once.


%the lines 2 and 3 in Figure 2
As another example, the data dependency from the \code{def-use}
relation via the variable \code{myButton} between line 2 and line 3 in
Figure~\ref{fig:example2} is useful in deriving the FQNs of the
above API elements. If a model decides the FQN for \code{Button} at
line 2 as \code{com\-.google\-.gwt\-.user\-.client\-.ui\-.Button}, it
could derive the FQN of \code{add\-Click\-Handler} at line~3 as
\code{com.\-google.\-gwt.\-user.\-client.\-ui.\-Button.\-add\-Click\-Handler},
and vice versa.

\vspace{2pt}
\noindent {\bf State-of-the-Art Approaches.} Several approaches have
been proposed to automatically recover the fully-qualified names
(FQNs) for the API elements in a code snippet. The {\em
  program-analysis-based} approaches (e.g.,
PPA~\cite{dagenais-oopsla08}, RecoDoc~\cite{dagenais-icse12}), {\em
  information-retrieval-based} approaches (e.g.,
Baker~\cite{liveapi14}, COSTER~\cite{coster-ase19}), and {\em
  constraint-based} approaches (e.g., SnR~\cite{snr-icse22}) suffer
the out-of-vocabulary issue (i.e., could not derive the FQNs that were
not seen in the training corpus).

The advances in {\em Artificial Intelligence (AI)} and {\em Machine
  Learning (ML)} have enabled the generation of the new FQNs for the
APIs. However, those ML-based approaches (e.g., StatType~\cite{icse18}
and Huang {\em et al.}~\cite{prompt-ase22}) still do not leverage the
regularity of API usages and the dependencies/relations among relevant
API elements for FQN recovery. StatType~\cite{icse18} uses
phrase-based statistical machine translation from the code without
FQNs to the one with them.  With short phrases of the lengths of 3-8
tokens, it cannot capture the relevant API elements yet far apart. For
example, in Figure~\ref{fig:example1}, such short phrases in StatType
cannot make the connections between the API elements \code{mButton}
and \code{setOnClickListener} at line 11 to the relevant API elements
\code{mButton}, \code{findViewById}, etc. at line 8. In other cases,
the two relevant statements that could help the FQN recovery might be
even farther in the code. In contrast, Huang {\em et
  al.}~\cite{prompt-ase22} uses the context of a few lines surrounding
the prediction point (e.g., line 11) for their filling-in approach
with a masked language model. First, a few lines might not capture the
relevant API elements in the same usage. In Figure~\ref{fig:example1},
\code{mButton} at line 1 is far apart from \code{mButton} at line 8
and \code{mButton} at line 11. Second, each API element might be used
in a different context in the client code. For example, the code at
line 9 in Figure~\ref{fig:example1} is specific to the method
\code{onCreate} at line 4. Thus, this type of context might not help a
model learn the FQN of an API.

\input{example4.tex}
%Talk about StatType and fill-in
